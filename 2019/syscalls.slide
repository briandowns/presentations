Syscalls in Go
Golang Phoenix
21 Mar 2018

Brian Downs
@bdowns328
@golangphoenix

* What is a syscall?

* 

- Syscalls are a means of abstracting kernel resources through a well defined interface to code running in userland.
- The word syscall is short for "system call".  These calls are made from programs to request service from the kernel. 

* Platform Syscalls

- 562 syscalls available on FreeBSD 
- ~313 on Linux
- These include creating new processes (fork, exec), accessing devices (open, close), as well as communications (send, receive)

* How does Go handle syscalls?

 package syscall

- Package syscall provides functions and methods for common syscalls across the supported operating systems. 
- These syscalls are wrappers around assembly for their architecture.

* ASM Examples

* Darwin AMD 64

 TEXT	·Syscall(SB),NOSPLIT,$0-56
    CALL	runtime·entersyscall(SB)
    MOVQ	a1+8(FP), DI
    MOVQ	a2+16(FP), SI
    MOVQ	a3+24(FP), DX
    MOVQ	$0, R10
    MOVQ	$0, R8
    MOVQ	$0, R9
    MOVQ	trap+0(FP), AX	// syscall entry
    ADDQ	$0x2000000, AX
    SYSCALL
    JCC	ok
    MOVQ	$-1, r1+32(FP)
    MOVQ	$0, r2+40(FP)
    MOVQ	AX, err+48(FP)
    CALL	runtime·exitsyscall(SB)
    RET
 ok:
    MOVQ	AX, r1+32(FP)
    MOVQ	DX, r2+40(FP)
    MOVQ	$0, err+48(FP)
    CALL	runtime·exitsyscall(SB)
    RET

* Linux AMD 64

 TEXT	·Syscall(SB),NOSPLIT,$0-56
    CALL	runtime·entersyscall(SB)
    MOVQ	a1+8(FP), DI
    MOVQ	a2+16(FP), SI
    MOVQ	a3+24(FP), DX
    MOVQ	$0, R10
    MOVQ	$0, R8
    MOVQ	$0, R9
    MOVQ	trap+0(FP), AX	// syscall entry
    SYSCALL
    CMPQ	AX, $0xfffffffffffff001
    JLS	ok
    MOVQ	$-1, r1+32(FP)
    MOVQ	$0, r2+40(FP)
    NEGQ	AX
    MOVQ	AX, err+48(FP)
    CALL	runtime·exitsyscall(SB)
    RET
 ok:
    MOVQ	AX, r1+32(FP)
    MOVQ	DX, r2+40(FP)
    MOVQ	$0, err+48(FP)
    CALL	runtime·exitsyscall(SB)
    RET

* What if they don't?

* FreeBSD

- FreeBSD syscall coverage in Go is sparse. 
- Most IO is covered as well as `kqueue`.

* Not Implemented FreeBSD Syscalls

 jail(2)
 jail_set(2)
 jail_get(2)
 jail_attach(2)
 jail_remove(2)

Using these syscalls you can take a process and lock it into it's own execution space with its own file system resources, and network.

* Calling an Unimplemented Syscall

* Step 1: Find the numeric value assigned to that syscall.  

- This can be found here in the syscall table. https://github.com/freebsd/freebsd/blob/master/sys/kern/syscalls.master

* Step 2: Remember that the underlying world of operating system development is done in C and curse under your breath.

- $*&^!* !!

* Step 3: Look what data the syscall takes

- From `man 2 jail` we see that the call takes a pointer to a jail struct. 
- For more detail we can reference the kernel header files: `sys/param.h` and `sys/jail.h`

 struct jail {
    uint32_t	       version; 
    char		       *path;
    char		       *hostname;
    char		       *jailname;
    unsigned int	   ip4s;
    unsigned int	   ip6s;
    struct in_addr     *ip4;
    struct in6_addr    *ip6;
 };

* Step 4: Create Data

 type jail struct {
    Version  uint32
    Path     uintptr
    Name     uintptr
    Hostname uintptr
    IP4s     uint32
    IP6s     uint32
    IP4      uintptr
    IP6      uintptr
 }

* Step 5: Convert Data to Necessary Forms

*  

Convert strings to byte pointers. 

 jn, err := syscall.BytePtrFromString("jail_name")
 if err != nil {
    return 0, err
 }
 jp, err := syscall.BytePtrFromString("jail_path")
 if err != nil {
    return 0, err
 }
 hn, err := syscall.BytePtrFromString("jail_hostname")
 if err != nil {
    return 0, err
 }

* 

We need to get the actual memory pointer and assign that to our struct. 

The kernel is implemented in C so this code is a port of that kernel code from the man page. Since it's C, ints are 32 bits wide so we need to account for that in our assignments.

 j := &jail{
    Version:  uint32(0), 
    Path:     uintptr(unsafe.Pointer(jp)),
    Hostname: uintptr(unsafe.Pointer(hn)),
    Name:     uintptr(unsafe.Pointer(jn)),
    IP4s:     uint32(1),
    IP6s:     uint32(0),
    IP4:      uintptr(unsafe.Pointer(ia)),
 }

* Step 6: Make the System Call

 r1, _, e1 := syscall.Syscall(sysJail, uintptr(unsafe.Pointer(j)), 0, 0)
 if e1 != 0 {
    return 0, fmt.Errorf("%d", e1)
 }

- `jail(2)` only returns an int containing the jail ID of a the created jail.  However `syscall.Syscall` returns 3 values. 
- In our case, the first will be the jail ID, the second will be blank, and an error. The error is pulled from the `ERNNO` value set by the kernel.

* Conclusion

- Writing your own functions and package to make syscalls is fairly easy with Go
- An understanding of your platforms relevant kernel code is necessary
- A limited understanding of C is necessary
- In most cases, you won't even need to do this

